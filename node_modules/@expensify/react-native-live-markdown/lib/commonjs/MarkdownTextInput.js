"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getWorkletRuntime = getWorkletRuntime;
var _reactNative = require("react-native");
var _react = _interopRequireDefault(require("react"));
var _reactNativeReanimated = require("react-native-reanimated");
var _MarkdownTextInputDecoratorViewNativeComponent = _interopRequireDefault(require("./MarkdownTextInputDecoratorViewNativeComponent.js"));
var _NativeLiveMarkdownModule = _interopRequireDefault(require("./NativeLiveMarkdownModule.js"));
var _styleUtils = require("./styleUtils.js");
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
let initialized = false;
let workletRuntime;
function getWorkletRuntime() {
  if (workletRuntime === undefined) {
    throw new Error("[react-native-live-markdown] Worklet runtime hasn't been created yet. Please avoid calling `getWorkletRuntime()` in top-level scope. Instead, call `getWorkletRuntime()` directly in `runOnRuntime` arguments list.");
  }
  return workletRuntime;
}
function initializeLiveMarkdownIfNeeded() {
  if (initialized) {
    return;
  }
  if (_NativeLiveMarkdownModule.default) {
    _NativeLiveMarkdownModule.default.install();
  }
  if (!global.jsi_setMarkdownRuntime) {
    throw new Error('[react-native-live-markdown] global.jsi_setMarkdownRuntime is not available');
  }
  workletRuntime = (0, _reactNativeReanimated.createWorkletRuntime)('LiveMarkdownRuntime');
  global.jsi_setMarkdownRuntime(workletRuntime);
  initialized = true;
}
function registerParser(parser) {
  initializeLiveMarkdownIfNeeded();
  const shareableWorklet = (0, _reactNativeReanimated.makeShareableCloneRecursive)(parser);
  const parserId = global.jsi_registerMarkdownWorklet(shareableWorklet);
  return parserId;
}
function unregisterParser(parserId) {
  global.jsi_unregisterMarkdownWorklet(parserId);
}
function processColorsInMarkdownStyle(input) {
  const output = JSON.parse(JSON.stringify(input));
  Object.keys(output).forEach(key => {
    const obj = output[key];
    Object.keys(obj).forEach(prop => {
      // TODO: use ReactNativeStyleAttributes from 'react-native/Libraries/Components/View/ReactNativeStyleAttributes'
      if (!(prop === 'color' || prop.endsWith('Color'))) {
        return;
      }
      obj[prop] = (0, _reactNative.processColor)(obj[prop]);
    });
  });
  return output;
}
function processMarkdownStyle(input) {
  return processColorsInMarkdownStyle((0, _styleUtils.mergeMarkdownStyleWithDefault)(input));
}
const MarkdownTextInput = /*#__PURE__*/_react.default.forwardRef((props, ref) => {
  const markdownStyle = _react.default.useMemo(() => processMarkdownStyle(props.markdownStyle), [props.markdownStyle]);
  if (props.parser === undefined) {
    throw new Error('[react-native-live-markdown] `parser` is undefined');
  }

  // eslint-disable-next-line no-underscore-dangle
  const workletHash = props.parser.__workletHash;
  if (workletHash === undefined) {
    throw new Error('[react-native-live-markdown] `parser` is not a worklet');
  }
  const parserId = _react.default.useMemo(() => {
    return registerParser(props.parser);
  }, [props.parser]);
  _react.default.useEffect(() => {
    return () => unregisterParser(parserId);
  }, [parserId]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_MarkdownTextInputDecoratorViewNativeComponent.default, {
    style: styles.displayContents,
    markdownStyle: markdownStyle,
    parserId: parserId,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.TextInput, {
      ...props,
      ref: ref
    })
  });
});
const styles = _reactNative.StyleSheet.create({
  displayContents: {
    display: 'contents'
  }
});
var _default = exports.default = MarkdownTextInput;
//# sourceMappingURL=MarkdownTextInput.js.map