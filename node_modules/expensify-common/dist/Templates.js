"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jquery_1 = __importDefault(require("jquery"));
const template_1 = __importDefault(require("lodash/template"));
const Utils = __importStar(require("./utils"));
/**
 * JS Templating system, powered by underscore template
 *
 * Templates is a global namespace for each template, HTML ones or inlines ones.
 *
 * @type Module
 * @constructor
 */
exports.default = (function () {
    const templateStore = {};
    /**
     * Class representing a registered template
     */
    class InlineTemplate {
        /**
         * Store a compiled template and id
         *
         * @param {String} templateValue
         */
        constructor(templateValue) {
            this.templateValue = templateValue;
            this.compiled = null;
            this.get = this.get.bind(this);
        }
        /**
         * Gets the compiled template using the provided data
         *
         * @param {Object} data
         *
         * @returns {String}
         */
        get(data = {}) {
            if (!this.compiled) {
                this.compiled = (0, template_1.default)(this.templateValue, {
                    imports: {
                        // Here we ignore the eslint rule because _ is imported from OD which does not exist in this repo
                        // eslint-disable-next-line no-undef, object-shorthand
                        _: _,
                    },
                });
                this.templateValue = '';
            }
            return this.compiled(data);
        }
    }
    /**
     * Class representing a template existing in the DOM
     */
    class DOMTemplate {
        /**
         * Store a compiled template and id
         * @param {String} id
         */
        constructor(id) {
            this.id = id;
            this.compiled = null;
            this.get = this.get.bind(this);
        }
        /**
         * Gets the compiled template using the provided data
         *
         * @param {Object} data
         *
         * @returns {String}
         */
        get(data = {}) {
            // Add the "template" object to the parameter to allow nested templates
            const dataToCompile = Object.assign({}, data);
            // eslint-disable-next-line no-undef
            dataToCompile.nestedTemplate = Templates.get;
            if (!this.compiled) {
                this.compiled = (0, template_1.default)((0, jquery_1.default)(`#${this.id}`).html(), {
                    imports: {
                        // Here we ignore the eslint rule because _ is imported from OD which does not exist in this repo
                        // eslint-disable-next-line no-undef, object-shorthand
                        _: _,
                    },
                });
            }
            return this.compiled(dataToCompile);
        }
    }
    /**
     * Returns the template
     *
     * @param {Array} templatePath
     * @return {InlineTemplate|undefined}
     */
    function getTemplate(templatePath) {
        let template = templateStore;
        templatePath.forEach((pathname) => {
            template = template[pathname];
        });
        return template;
    }
    /**
     * Based on an array of string, return a reference to the object that should hold the template
     * used to augment the template object
     *
     * @param {Array} wantedNamespace Array of string reprensenting the namespace
     * @return {Object} Referene to the object holding the namespace
     */
    function getTemplateNamespace(wantedNamespace) {
        let namespace = templateStore;
        let currentArgument;
        for (let argumentNumber = 0; argumentNumber < wantedNamespace.length; argumentNumber++) {
            currentArgument = wantedNamespace[argumentNumber];
            if (namespace[currentArgument] === undefined) {
                namespace[currentArgument] = {};
            }
            namespace = namespace[currentArgument];
        }
        return namespace;
    }
    return {
        /**
         * Given a templatePath, return the value
         *
         * @param {Array} templatePath
         * @param {Object} [data] Information that need to be injected into the template
         * @return {String}
         */
        get(templatePath, data = {}) {
            const template = getTemplate(templatePath);
            if (template === undefined) {
                throw Error(`Template '${templatePath}' is not defined`);
            }
            // Check for the absense of get which means someone is likely using
            // the templating engine wrong and trying to access a template namespace
            if (!{}.propertyIsEnumerable.call(template, 'get')) {
                throw Error(`'${templatePath}' is not a valid template path`);
            }
            return template.get(data);
        },
        /**
         * Given a templatePath, does it have a registered template?
         * @param  {Array} templatePath
         * @return {Boolean}
         */
        has(templatePath) {
            return getTemplate(templatePath) !== undefined;
        },
        /**
         * Inits the templating engine, and slurps all DOM templates in an internal data structure
         */
        init() {
            // Read the DOM to find all the templates, and make them available to the code
            // eslint-disable-next-line rulesdir/prefer-underscore-method
            (0, jquery_1.default)('.js_template').each((__, $el) => {
                const namespaceElements = $el.id.split('_');
                const id = namespaceElements.pop();
                // remove the prefix "template" that MUST be added to have clean HTML ids
                namespaceElements.shift();
                const namespace = getTemplateNamespace(namespaceElements);
                namespace[id] = new DOMTemplate($el.id);
            });
        },
        /**
         * Register a new json object in the template manager
         *
         * @param {Array} wantedNamespace Namespace where we want to store the templates
         * @param {object} templateData The literal object that contain the templates
         */
        register(wantedNamespace, templateData) {
            const namespace = getTemplateNamespace(wantedNamespace);
            Object.keys(templateData).forEach((key) => {
                const template = templateData[key];
                if (Utils.isObject(template)) {
                    // If the template is an object, add templates for all keys
                    namespace[key] = {};
                    Object.keys(template).forEach((templateKey) => {
                        namespace[key][templateKey] = new InlineTemplate(template[templateKey]);
                    });
                }
                else {
                    namespace[key] = new InlineTemplate(template);
                }
            });
        },
        /**
         * Removes a namespace from the templateStore (only used for testing purposes)
         *
         * @param {String} nameSpace
         */
        unregister(nameSpace) {
            delete templateStore[nameSpace];
        },
        /**
         * Replace the DOM HTML with the template value
         *
         * @param {jQuery} $target Element(s) that will be updated
         * @param {Array} templatePath
         * @param {Object} [data] Information that need to be injected into the template
         */
        insert($target, templatePath, data = {}) {
            $target.html(this.get(templatePath, data));
        },
        /**
         * Append the template value into a DOM elements
         *
         * @param {jQuery} $target Element(s) that will be updated
         * @param {Array} templatePath
         * @param {Object} data Information that need to be injected into the template
         */
        prepend($target, templatePath, data) {
            $target.prepend(this.get(templatePath, data));
        },
        /**
         * Prepend the template value into a DOM elements
         *
         * @param {jQuery} $target Element(s) that will be updated
         * @param {array} templatePath
         * @param {object} [data] Information that need to be injected into the template
         */
        append($target, templatePath, data) {
            $target.append(this.get(templatePath, data));
        },
    };
})();
