import Logger from './Logger';
type Extras = {
    reportIDToName?: Record<string, string>;
    accountIDToName?: Record<string, string>;
    /**
     * @deprecated Replaced with mediaAttributeCachingFn
     */
    cacheVideoAttributes?: (vidSource: string, attrs: string) => void;
    /**
     * @deprecated Replaced with mediaAttributeCache
     */
    videoAttributeCache?: Record<string, string>;
    /**
     * Function used to cache HTML tag attributes during conversion to and from Markdown
     * @param mediaSource URI to media source
     * @param attrs Additional attributes to be cached
     */
    mediaAttributeCachingFn?: (mediaSource: string, attrs: string) => void;
    /**
     * Key/value cache for HTML tag attributes, where the key is media source URI, value is cached attributes
     */
    mediaAttributeCache?: Record<string, string>;
};
export type { Extras };
type ReplacementFn = (extras: Extras, ...matches: string[]) => string;
type Replacement = ReplacementFn | string;
type ProcessFn = (textToProcess: string, replacement: Replacement, shouldKeepRawInput: boolean) => string;
type CommonRule = {
    name: string;
    replacement: Replacement;
    rawInputReplacement?: Replacement;
    pre?: (input: string) => string;
    post?: (input: string) => string;
};
type RuleWithRegex = CommonRule & {
    regex: RegExp;
};
type RuleWithProcess = CommonRule & {
    process: ProcessFn;
};
type Rule = RuleWithRegex | RuleWithProcess;
type ReplaceOptions = {
    extras?: Extras;
    filterRules?: string[];
    disabledRules?: string[];
    shouldEscapeText?: boolean;
    shouldKeepRawInput?: boolean;
};
type TruncateOptions = {
    ellipsis?: string;
    truncateLastWord?: boolean;
    slop?: number;
    removeImageTag?: boolean;
};
export default class ExpensiMark {
    getAttributeCache: (extras?: Extras) => {
        attrCachingFn: ((vidSource: string, attrs: string) => void) | undefined;
        attrCache: Record<string, string> | undefined;
    };
    static Log: Logger;
    /**
     * Set the logger to use for logging inside of the ExpensiMark class
     * @param logger - The logger object to use
     */
    static setLogger(logger: Logger): void;
    /** Rules to apply to the text */
    rules: Rule[];
    /**
     * The list of regex replacements to do on a HTML comment for converting it to markdown.
     * Order of rules is important
     */
    htmlToMarkdownRules: RuleWithRegex[];
    /**
     * The list of rules to covert the HTML to text.
     * Order of rules is important
     */
    htmlToTextRules: RuleWithRegex[];
    /**
     * The list of rules that we have to exclude in shouldKeepWhitespaceRules list.
     */
    whitespaceRulesToDisable: string[];
    /**
     * The list of rules that have to be applied when shouldKeepWhitespace flag is true.
     */
    filterRules: (rule: Rule) => boolean;
    /**
     * Filters rules to determine which should keep whitespace.
     */
    shouldKeepWhitespaceRules: Rule[];
    /**
     * maxQuoteDepth is the maximum depth of nested quotes that we want to support.
     */
    maxQuoteDepth: number;
    /**
     * currentQuoteDepth is the current depth of nested quotes that we are processing.
     */
    currentQuoteDepth: number;
    constructor();
    /**
     * Retrieves the HTML ruleset based on the provided filter rules, disabled rules, and shouldKeepRawInput flag.
     * @param filterRules - An array of rule names to filter the ruleset.
     * @param disabledRules - An array of rule names to disable in the ruleset.
     * @param shouldKeepRawInput - A boolean flag indicating whether to keep raw input.
     */
    getHtmlRuleset(filterRules: string[], disabledRules: string[], shouldKeepRawInput: boolean): Rule[];
    /**
     * Replaces markdown with html elements
     *
     * @param text - Text to parse as markdown
     * @param [options] - Options to customize the markdown parser
     * @param [options.filterRules=[]] - An array of name of rules as defined in this class.
     * If not provided, all available rules will be applied.
     * @param [options.shouldEscapeText=true] - Whether or not the text should be escaped
     * @param [options.disabledRules=[]] - An array of name of rules as defined in this class.
     * If not provided, all available rules will be applied. If provided, the rules in the array will be skipped.
     */
    replace(text: string, { filterRules, shouldEscapeText, shouldKeepRawInput, disabledRules, extras }?: ReplaceOptions): string;
    /**
     * Checks matched URLs for validity and replace valid links with html elements
     */
    modifyTextForUrlLinks(regex: RegExp, textToCheck: string, replacement: ReplacementFn): string;
    /**
     * Checks matched Emails for validity and replace valid links with html elements
     */
    modifyTextForEmailLinks(regex: RegExp, textToCheck: string, replacement: ReplacementFn, shouldKeepRawInput: boolean): string;
    /**
     * replace block element with '\n' if :
     * 1. We have text within the element.
     * 2. The text does not end with a new line.
     * 3. It's not the last element in the string.
     */
    replaceBlockElementWithNewLine(htmlString: string): string;
    /**
     * Unpacks nested quote HTML tags that have been packed by the 'quote' rule in this.rules for shouldKeepRawInput = false
     *
     * For example, it parses the following HTML:
     * <blockquote>
     *     quote 1
     *    <blockquote>
     *      quote 2
     *    </blockquote>
     *    quote 3
     * </blockquote>
     *
     * into:
     * <blockquote> quote 1</blockquote>
     * <blockquote><blockquote> quote 2</blockquote>
     * <blockquote> quote 3</blockquote>
     *
     * Note that there will always be only a single closing tag, even if multiple opening tags exist.
     * Only one closing tag is needed to detect if a nested quote has ended.
     */
    unpackNestedQuotes(text: string): string;
    /**
     * Replaces HTML with markdown
     */
    htmlToMarkdown(htmlString: string, extras?: Extras): string;
    /**
     * Convert HTML to text
     */
    htmlToText(htmlString: string, extras?: Extras): string;
    /**
     * Main text to html 'quote' parsing logic.
     * Removes &gt;( ) from text and recursively calls replace function to process nested quotes and build blockquote HTML result.
     * @param shouldKeepRawInput determines if the raw input should be kept for nested quotes.
     */
    replaceQuoteText(text: string, shouldKeepRawInput: boolean): {
        replacedText: string;
        shouldAddSpace: boolean;
    };
    /**
     * Check if the input text includes only the open or the close tag of an element.
     */
    containsNonPairTag(textToCheck: string): boolean;
    /**
     * @returns array or undefined if exception occurs when executing regex matching
     */
    extractLinksInMarkdownComment(comment: string): string[] | undefined;
    /**
     * Compares two markdown comments and returns a list of the links removed in a new comment.
     */
    getRemovedMarkdownLinks(oldComment: string, newComment: string): string[];
    /**
     * Escapes the content of an HTML attribute value
     * @param content - string content that possible contains HTML
     * @returns original MD content escaped for use in HTML attribute value
     */
    escapeAttributeContent(content: string): string;
    /**
     * Determines the end position to truncate the HTML content while considering word boundaries.
     *
     * @param {string} content - The HTML content to be truncated.
     * @param {number} tailPosition - The position up to which the content should be considered.
     * @param {number} maxLength - The maximum length of the truncated content.
     * @param {number} totalLength - The length of the content processed so far.
     * @param {Object} opts - Options to customize the truncation.
     * @returns {number} The calculated position to truncate the content.
     */
    getEndPosition(content: string, tailPosition: number | undefined, maxLength: number, totalLength: number, opts: TruncateOptions): number;
    /**
     * Truncate HTML string and keep tag safe.
     * pulled from https://github.com/huang47/nodejs-html-truncate/blob/master/lib/truncate.js
     *
     * @param {string} html - The string that needs to be truncated
     * @param {number} maxLength - Length of truncated string
     * @param {Object} [options] - Optional configuration options
     * @returns {string} The truncated string
     */
    truncateHTML(html: string, maxLength: number, options?: TruncateOptions): string;
    /**
     * Replaces text with a replacement based on a regex
     * @param text - The text to replace
     * @param regexp - The regex to match
     * @param extras - The extras object
     * @param replacement - The replacement string or function
     * @returns The replaced text
     */
    replaceTextWithExtras(text: string, regexp: RegExp, extras: Extras, replacement: Replacement): string;
}
