export default Combobox;
/**
 * A combobox useful for searching for values in a large list
 */
declare class Combobox extends React.Component<any, any, any> {
    constructor(props: any);
    /**
     * @param {Boolean} noDefaultValue Overrides the default value to have '' as the currentValue
     * @param {Object[]} [newOptions] when resetting this component, we can specify new options to use
     * @param {Object[]} [newAlreadySelectedOptions] when resetting this component, we can specify new already selected options to use
     *
     * @returns {Object}
     */
    getStartState(noDefaultValue: boolean, newOptions?: Object[], newAlreadySelectedOptions?: Object[]): Object;
    /**
     * Returns a set of our full options according to the maxItemsToShow
     *
     * @param {String|Number} currentValue
     * @param {Object[]} [newAlreadySelectedOptions]
     * @returns {Array}
     */
    getTruncatedOptions(currentValue: string | number, newAlreadySelectedOptions?: Object[]): any[];
    /**
     * Returns the selected value(s)
     *
     * @return {String}
     */
    getValue(): string;
    /**
     * Sets the current value
     *
     * @param {String} val
     */
    setValue(val: string): void;
    /**
     * Hard sets the current text to what we want
     *
     * @param {String} val
     */
    setText(val: string): void;
    /**
     * Sets the disabled state of this component
     *
     * @param {Boolean} isDisabled
     */
    setDisabled(isDisabled: boolean): void;
    /**
     * Set an error for a specific tag
     */
    setError(): void;
    /**
     * Deselects any current option if it exists
     */
    deselectCurrentOption(): void;
    /**
     * Swaps the focused index from {oldFocusedIndex} to {newFocusedIndex}
     *
     * @param {number} oldFocusedIndex
     * @param {number} newFocusedIndex
     */
    switchFocusedIndex(oldFocusedIndex: number, newFocusedIndex: number): void;
    /**
     * Returns the selector to it's original state
     *
     * @param {Boolean} noDefaultValue Overrides the initials state defaultValue by setting the currentValue to ''
     * @param {Object[]} [newOptions] we can recreate it with new options
     * @param {Object[]} [newAlreadySelectedOptions] we can recreate it with new already selected options
     */
    reset(noDefaultValue: boolean, newOptions?: Object[], newAlreadySelectedOptions?: Object[]): void;
    /**
     * When the dropdown is closed, we reset the focused property of all of our options
     */
    resetFocusedElements(): void;
    /**
     * Fired when we "click away" with the dropdown open
     *
     * @param {SyntheticEvent} e
     */
    handleClickAway(e: SyntheticEvent): void;
    /**
     * Sets a clicklistener to close the dropdown if it is currently open
     */
    resetClickAwayHandler(): void;
    /**
     * Clear an error for a specific tag
     */
    clearError(): void;
    /**
     * Opens or closes the dropdown
     */
    toggleDropdown(): void;
    /**
     * Just open the dropdown (when the input gets focus)
     */
    openDropdown(): void;
    /**
     * Closes the dropdown and removes the click handler that calls this function after the dropdown is closed
     *
     * @param {SyntheticEvent} [e]
     */
    closeDropdown(e?: SyntheticEvent): void;
    /**
     * If the user presses tab when the dropdown button is focused, then we close the dropdown
     * because they are trying to get to the next form components
     *
     * @param {SyntheticEvent} e
     */
    closeDropdownOnTabOut(e: SyntheticEvent): void;
    /**
     * Stops events from doing anything outside of the current function (in theory).
     * This doesn't work between jquery and React events because React's event propagation is a separate system.
     *
     * @param {SyntheticEvent} e
     */
    stopEvent(e: SyntheticEvent): void;
    /**
     * This is triggered whenever there is a key up event in the text input
     *
     * @param {SyntheticEvent} e
     */
    handleKeyDown(e: SyntheticEvent): void;
    /**
     * This is triggered whenever there is a change event in the text input
     * (from any valid input that's not being handled from the keyUp event)
     *
     * @param {SyntheticEvent} e
     */
    performSearch(e: SyntheticEvent): void;
    /**
     * Handle state changes for when a user clicks on an item in the dropdown
     *
     * @param  {String|Number} selectedValue
     */
    handleClick(selectedValue: string | number): void;
    state: Object;
    scrollPosition: number;
    componentDidMount(): void;
    UNSAFE_componentWillReceiveProps(nextProps: any): void;
    componentDidUpdate(): void;
    componentWillUnmount(): void;
    initialValue: any;
    options: any;
    initialText: any;
    render(): React.JSX.Element | null;
    value: HTMLInputElement | null | undefined;
    dropDown: DropDown | null | undefined;
}
declare namespace Combobox {
    export { propTypes };
    export { defaultProps };
}
import React from 'react';
import DropDown from './dropdown';
declare namespace propTypes {
    let options: PropTypes.Validator<(PropTypes.InferProps<{
        value: PropTypes.Requireable<NonNullable<string | number | null | undefined>>;
        text: PropTypes.Requireable<string>;
        children: PropTypes.Requireable<PropTypes.ReactElementLike>;
        hasError: PropTypes.Requireable<boolean>;
        disabled: PropTypes.Requireable<boolean>;
        id: PropTypes.Requireable<NonNullable<string | number | null | undefined>>;
        divider: PropTypes.Requireable<boolean>;
        selected: PropTypes.Requireable<boolean>;
    }> | null | undefined)[]>;
    let defaultValue: PropTypes.Requireable<NonNullable<string | number | null | undefined>>;
    let value: PropTypes.Requireable<NonNullable<string | number | null | undefined>>;
    let alreadySelectedOptions: PropTypes.Requireable<(PropTypes.InferProps<{
        id: PropTypes.Requireable<NonNullable<string | number | null | undefined>>;
        value: PropTypes.Requireable<NonNullable<string | number | null | undefined>>;
        text: PropTypes.Requireable<string>;
    }> | null | undefined)[]>;
    let onChange: PropTypes.Requireable<(...args: any[]) => any>;
    let onClear: PropTypes.Requireable<(...args: any[]) => any>;
    let onDropdownStateChange: PropTypes.Requireable<(...args: any[]) => any>;
    let maxItemsToShow: PropTypes.Requireable<number>;
    let maxSearchResults: PropTypes.Requireable<number>;
    let propertyToDisplay: PropTypes.Requireable<string>;
    let openOnInit: PropTypes.Requireable<boolean>;
    let allowAnyValue: PropTypes.Requireable<boolean>;
    let noResultsText: PropTypes.Requireable<string>;
    let isReadOnly: PropTypes.Requireable<boolean>;
    let placeholder: PropTypes.Requireable<string>;
    let extraClasses: PropTypes.Requireable<NonNullable<string | object | null | undefined>>;
    let hideUntilManuallyOpened: PropTypes.Requireable<boolean>;
    let alwaysShowSelectedOnTop: PropTypes.Requireable<boolean>;
    let hasInitialError: PropTypes.Requireable<boolean>;
    let bs4: PropTypes.Requireable<boolean>;
    let showDisabledOptionsInResults: PropTypes.Requireable<boolean>;
    let autoScrollToTop: PropTypes.Requireable<boolean>;
    let dropDownClasses: PropTypes.Requireable<NonNullable<string | object | null | undefined>>;
}
declare namespace defaultProps {
    let defaultValue_1: string;
    export { defaultValue_1 as defaultValue };
    let value_1: string;
    export { value_1 as value };
    export function onChange_1(): void;
    export { onChange_1 as onChange };
    export function onClear_1(): void;
    export { onClear_1 as onClear };
    export function onDropdownStateChange_1(): void;
    export { onDropdownStateChange_1 as onDropdownStateChange };
    let maxItemsToShow_1: number;
    export { maxItemsToShow_1 as maxItemsToShow };
    let maxSearchResults_1: number;
    export { maxSearchResults_1 as maxSearchResults };
    let propertyToDisplay_1: string;
    export { propertyToDisplay_1 as propertyToDisplay };
    let allowAnyValue_1: boolean;
    export { allowAnyValue_1 as allowAnyValue };
    let openOnInit_1: boolean;
    export { openOnInit_1 as openOnInit };
    let isReadOnly_1: boolean;
    export { isReadOnly_1 as isReadOnly };
    let alreadySelectedOptions_1: never[];
    export { alreadySelectedOptions_1 as alreadySelectedOptions };
    let noResultsText_1: string;
    export { noResultsText_1 as noResultsText };
    let placeholder_1: string;
    export { placeholder_1 as placeholder };
    let extraClasses_1: never[];
    export { extraClasses_1 as extraClasses };
    let hideUntilManuallyOpened_1: boolean;
    export { hideUntilManuallyOpened_1 as hideUntilManuallyOpened };
    let alwaysShowSelectedOnTop_1: boolean;
    export { alwaysShowSelectedOnTop_1 as alwaysShowSelectedOnTop };
    let hasInitialError_1: boolean;
    export { hasInitialError_1 as hasInitialError };
    let bs4_1: boolean;
    export { bs4_1 as bs4 };
    let showDisabledOptionsInResults_1: boolean;
    export { showDisabledOptionsInResults_1 as showDisabledOptionsInResults };
    let autoScrollToTop_1: boolean;
    export { autoScrollToTop_1 as autoScrollToTop };
    let dropDownClasses_1: never[];
    export { dropDownClasses_1 as dropDownClasses };
}
import PropTypes from 'prop-types';
