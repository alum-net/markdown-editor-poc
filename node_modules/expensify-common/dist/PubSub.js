"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const has_1 = __importDefault(require("lodash/has"));
const once_1 = __importDefault(require("lodash/once"));
const Log_1 = __importDefault(require("./Log"));
const Utils = __importStar(require("./utils"));
/**
 * PubSub
 *
 * A simple publisher subscriber system for async / decouple/ cross module communication
 */
const eventMap = {};
// Used to generate the uniq id of the event
let counter = 0;
/**
 * Create a unique ID for each event subscriber
 * @param {String} eventName Name of the event to listen to
 * @return {String} unique ID
 */
const generateID = (eventName) => {
    counter++;
    return `${eventName}@#@${counter}`;
};
/**
 * Find the name of the event from the ID
 * @param {string} eventID
 * @return {String}
 */
const extractEventName = (eventID = '') => eventID.substring(0, eventID.indexOf('@#@'));
const PubSubModule = {
    ERROR: 'ev_error',
    /**
     * Publish an event
     *
     * @param {String} eventName Name of the event to fire
     * @param {Object} [param] Parameters to send with the event, send to the callback
     * @returns {PubSub}
     */
    publish(eventName, param = {}) {
        if (eventMap[eventName] === undefined) {
            return;
        }
        const eventIDs = Object.keys(eventMap[eventName]);
        if (eventName === this.ERROR) {
            // Doing the split slice 2 because the 1st element of the stacktrace will always be from here (PubSub.publish)
            // When debugging, we just need to know who called PubSub.publish (so, all next elements in the stack)
            Log_1.default.hmmm('Error published', 0, { tplt: param.tplt, stackTrace: new Error().stack.split(' at ').slice(2) });
        }
        eventIDs.forEach((eventID) => {
            const subscriber = eventMap[eventName][eventID];
            if (subscriber) {
                subscriber.callback.call(subscriber.scope, param);
            }
        });
        return this;
    },
    /**
     * Subscribes to an event and triggers the callback only once with the given scope
     *
     * @param  {String}   eventName
     * @param  {Function} callback
     * @param  {Object}   [optionalScope]
     * @returns {String}
     */
    once(eventName, callback, optionalScope) {
        const scope = Utils.isObject(optionalScope) && optionalScope !== null ? optionalScope : window;
        const functionToCallOnce = (0, once_1.default)((...args) => callback.apply(scope, args));
        return this.subscribe(eventName, functionToCallOnce);
    },
    /**
     * Listen to an event and call the callback when it is done.
     * Order of callback call is not guaranteed
     *
     * "PUBLIC" event ( aka for views ) are available in lib/constant.js
     * "PRIVATE" event should be used only by system modules
     *
     * @param {String} eventName Name of the event to listen
     * @param {Function} optionalCallback Callback function to call when event occur
     * @param {Object} optionalScope
     * @return {String} event identifier that should be used to unsubscribe
     */
    subscribe(eventName, optionalCallback, optionalScope) {
        if (!eventName) {
            throw new Error('Attempted to subscribe to undefined event');
        }
        const callback = Utils.isFunction(optionalCallback) ? optionalCallback : () => { };
        const scope = Utils.isObject(optionalScope) && optionalScope !== null ? optionalScope : window;
        const eventID = generateID(eventName);
        if (eventMap[eventName] === undefined) {
            eventMap[eventName] = {};
        }
        eventMap[eventName][eventID] = {
            callback,
            scope,
        };
        return eventID;
    },
    /**
     * Remove a subscriber
     *
     * @param {String} bindID The id of the element to delete
     */
    unsubscribe(bindID) {
        const IDs = Array.isArray(bindID) ? bindID : [bindID];
        IDs.forEach((id) => {
            const eventName = extractEventName(id);
            if ((0, has_1.default)(eventMap, `${eventName}.${id}`)) {
                delete eventMap[eventName][id];
            }
        });
    },
};
exports.default = Utils.isWindowAvailable() && window.PubSub ? window.PubSub : PubSubModule;
