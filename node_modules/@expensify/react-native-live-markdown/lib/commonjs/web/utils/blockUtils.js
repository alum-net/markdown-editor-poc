"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MULTILINE_MARKDOWN_TYPES = void 0;
exports.addStyleToBlock = addStyleToBlock;
exports.extendBlockStructure = extendBlockStructure;
exports.getFirstBlockMarkdownRange = getFirstBlockMarkdownRange;
exports.isBlockMarkdownType = isBlockMarkdownType;
exports.isChildOfMarkdownElement = isChildOfMarkdownElement;
exports.isChildOfMultilineMarkdownElement = isChildOfMultilineMarkdownElement;
exports.isMultilineMarkdownType = isMultilineMarkdownType;
var _styleUtils = require("../../styleUtils.js");
var _inlineImage = require("../inputElements/inlineImage.js");
function addStyleToBlock(targetElement, type, markdownStyle, isMultiline = true) {
  const node = targetElement;
  switch (type) {
    case 'line':
      Object.assign(node.style, {
        margin: '0',
        padding: '0'
      });
      break;
    case 'syntax':
      Object.assign(node.style, markdownStyle.syntax);
      break;
    case 'bold':
      node.style.fontWeight = 'bold';
      break;
    case 'italic':
      node.style.fontStyle = 'italic';
      break;
    case 'strikethrough':
      node.style.textDecoration = 'line-through';
      break;
    case 'emoji':
      Object.assign(node.style, {
        ...markdownStyle.emoji,
        verticalAlign: 'middle',
        fontStyle: 'normal',
        // remove italic
        textDecoration: 'none',
        // remove strikethrough
        display: 'inline-block'
      });
      break;
    case 'mention-here':
      Object.assign(node.style, markdownStyle.mentionHere);
      break;
    case 'mention-user':
      Object.assign(node.style, markdownStyle.mentionUser);
      break;
    case 'mention-report':
      Object.assign(node.style, markdownStyle.mentionReport);
      break;
    case 'link':
      Object.assign(node.style, {
        ...markdownStyle.link,
        textDecoration: 'underline'
      });
      break;
    case 'code':
    case 'pre':
      addCodeBlockStyles(targetElement, type, markdownStyle, isMultiline);
      break;
    case 'blockquote':
      Object.assign(node.style, {
        ...markdownStyle.blockquote,
        borderLeftStyle: 'solid',
        display: 'inline-block',
        maxWidth: '100%',
        boxSizing: 'border-box',
        overflowWrap: 'anywhere'
      });
      break;
    case 'h1':
      Object.assign(node.style, {
        ...markdownStyle.h1,
        fontWeight: 'bold'
      });
      break;
    case 'block':
      Object.assign(node.style, {
        display: 'block',
        margin: '0',
        padding: '0',
        position: 'relative'
      });
      break;
    case 'text':
      if (!isMultiline && targetElement.parentElement?.style) {
        // Move text background styles from parent to the text node
        const parentElement = targetElement.parentElement;
        node.style.cssText = parentElement.style.cssText;
        parentElement.style.cssText = '';
      }
      break;
    default:
      break;
  }
}
function addCodeBlockStyles(targetElement, type, markdownStyle, isMultiline = true) {
  const node = targetElement;
  const defaultPrePadding = markdownStyle.pre?.padding ?? 2;
  const preHorizontalPadding = (0, _styleUtils.parseStringWithUnitToNumber)(markdownStyle.pre?.paddingHorizontal ?? defaultPrePadding).toString();
  const preVerticalPadding = (0, _styleUtils.parseStringWithUnitToNumber)(markdownStyle.pre?.paddingVertical ?? defaultPrePadding).toString();
  const defaultCodePadding = markdownStyle.code?.padding ?? 0;
  const codeHorizontalPadding = (0, _styleUtils.parseStringWithUnitToNumber)(markdownStyle.code?.paddingHorizontal ?? defaultCodePadding).toString();
  const codeVerticalPadding = (0, _styleUtils.parseStringWithUnitToNumber)(markdownStyle.code?.paddingVertical ?? defaultCodePadding).toString();
  switch (type) {
    case 'code':
      Object.assign(node.style, {
        ...markdownStyle.code,
        fontSize: markdownStyle.code?.h1NestedFontSize && isChildOfMarkdownElement(node, 'h1') ? markdownStyle.code.h1NestedFontSize : markdownStyle.code?.fontSize,
        padding: `${codeVerticalPadding}px ${codeHorizontalPadding}px`,
        lineHeight: 1.5
      });
      break;
    case 'pre':
      // In multiline style the pre block using pseudoelements, otherwise default to inline
      if (isMultiline) {
        Object.assign(node.style, {
          ...markdownStyle.pre,
          padding: `${preVerticalPadding}px ${preHorizontalPadding}px`
        });
      } else {
        Object.assign(node.style, {
          ...markdownStyle.code,
          padding: `${codeVerticalPadding}px ${codeHorizontalPadding}px`,
          lineHeight: 1.5
        });
      }
      break;
    default:
      break;
  }
}
const BLOCK_MARKDOWN_TYPES = ['inline-image'];
const FULL_LINE_MARKDOWN_TYPES = ['blockquote'];
const MULTILINE_MARKDOWN_TYPES = exports.MULTILINE_MARKDOWN_TYPES = ['codeblock'];
function isBlockMarkdownType(type) {
  return BLOCK_MARKDOWN_TYPES.includes(type);
}
function isMultilineMarkdownType(type) {
  return MULTILINE_MARKDOWN_TYPES.includes(type);
}
function getFirstBlockMarkdownRange(ranges) {
  const blockMarkdownRange = ranges.find(r => isBlockMarkdownType(r.type) || FULL_LINE_MARKDOWN_TYPES.includes(r.type));
  return blockMarkdownRange && FULL_LINE_MARKDOWN_TYPES.includes(blockMarkdownRange.type) ? undefined : blockMarkdownRange;
}
function extendBlockStructure(currentInput, targetNode, currentRange, ranges, text, markdownStyle, inlineImagesProps) {
  switch (currentRange.type) {
    case 'inline-image':
      return (0, _inlineImage.addInlineImagePreview)(currentInput, targetNode, text, ranges, markdownStyle, inlineImagesProps);
    default:
      break;
  }
  return targetNode;
}
function isDescendantOfMarkdownElement(node, predicate) {
  let currentNode = node.parentNode;
  while (currentNode && currentNode?.contentEditable !== 'true') {
    const elementType = currentNode.getAttribute?.('data-type');
    if (predicate(elementType)) {
      return true;
    }
    currentNode = currentNode.parentNode;
  }
  return false;
}
function isChildOfMarkdownElement(node, elementType) {
  return isDescendantOfMarkdownElement(node, type => type === elementType);
}
function isChildOfMultilineMarkdownElement(node) {
  return isDescendantOfMarkdownElement(node, type => MULTILINE_MARKDOWN_TYPES.includes(type));
}
//# sourceMappingURL=blockUtils.js.map