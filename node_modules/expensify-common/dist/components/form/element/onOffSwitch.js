"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const prop_types_1 = __importDefault(require("prop-types"));
const classnames_1 = __importDefault(require("classnames"));
const Func_1 = require("../../../Func");
const CONST_1 = require("../../../CONST");
const switch_1 = __importDefault(require("./switch"));
/**
 * Displays an on off switch (optionally) with label
 */
const propTypes = {
    // A unique identifier
    id: prop_types_1.default.string.isRequired,
    // Label to be displayed left to the switch
    label: prop_types_1.default.string,
    // True if the label should be on the right
    labelOnRight: prop_types_1.default.bool,
    // Classes of the label
    // eslint-disable-next-line react/forbid-prop-types
    labelClasses: prop_types_1.default.any,
    // True if the switch is on
    checked: prop_types_1.default.bool.isRequired,
    // Callback function to call when changing the switch (optional)
    onChangeCallback: prop_types_1.default.func,
    // Element to be displayed below the switch when it's on (optional)
    children: prop_types_1.default.node,
    // Disable edition of the switch (optional)
    preventEdit: prop_types_1.default.bool,
    // Description to be displayed below the switch (optional)
    description: prop_types_1.default.string,
    // If set to true, the description of the switch is only displayed when it is in the 'checked' state (optional)
    onlyShowDescriptionWhenOn: prop_types_1.default.bool,
    // If set to true, children elements won't be applied a left padding (optional)
    noLeftPaddingOnChildren: prop_types_1.default.bool,
    // Whether we should always show the children classes
    alwaysShowChildren: prop_types_1.default.bool,
    // If set to true, the description of the switch will be placed above the children elements (optional)
    descriptionBeforeChildren: prop_types_1.default.bool,
    // Safety check to ensure we are using dangerouslySetInnerHTML() safely
    safeDescription: prop_types_1.default.bool,
    // An array of extra classes to put on the combobox
    extraClasses: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.array, prop_types_1.default.object]),
    // There is usually text just following a switch that says "ENABLED" and "DISABLED" and
    // you can use this option to hide that text
    hideEnabledDisabledText: prop_types_1.default.bool,
    // Text to display in a tooltip
    tooltipText: prop_types_1.default.string,
};
const defaultProps = {
    label: '',
    labelOnRight: false,
    labelClasses: null,
    onChangeCallback: () => { },
    children: null,
    preventEdit: false,
    description: '',
    onlyShowDescriptionWhenOn: false,
    noLeftPaddingOnChildren: false,
    alwaysShowChildren: false,
    descriptionBeforeChildren: false,
    safeDescription: false,
    hideEnabledDisabledText: false,
    extraClasses: [],
    tooltipText: '',
};
class OnOffSwitch extends react_1.Component {
    constructor(props) {
        super(props);
        this.onChangeCallback = this.onChangeCallback.bind(this);
        this.lock = this.lock.bind(this);
        this.unlock = this.unlock.bind(this);
        this.getValue = this.getValue.bind(this);
        this.toggle = this.toggle.bind(this);
        this.state = {
            checked: this.props.checked,
            preventEdit: this.props.preventEdit,
            preventEditDescription: '',
        };
    }
    /**
     * Callback function called after toggling the switch
     * @param {boolean} newState
     */
    onChangeCallback(newState) {
        (0, Func_1.invoke)(this.props.onChangeCallback, [newState]);
        this.setState({
            checked: newState,
        });
    }
    /**
     * Is the switch on or off ?
     *
     * @returns {boolean} true if on
     */
    getValue() {
        return this.state.checked;
    }
    /**
     * Toggle the state of this switch.
     *
     * Note: this is used via refs, so please don't delete it unless you know what you're doing :D
     */
    toggle() {
        this.setState((prevState) => ({
            checked: !prevState.checked,
        }));
    }
    /**
     * Force switch off and prevent editing it
     * @param {boolean} checked
     * @param {string} msg
     */
    lock(checked, msg) {
        this.setState({
            checked,
            preventEdit: true,
            preventEditDescription: msg,
        });
    }
    /**
     * Release switch to its original value, and allow editing it
     */
    unlock() {
        this.setState((prevState) => ({
            checked: prevState.checked,
            preventEdit: false,
            preventEditDescription: '',
        }));
    }
    render() {
        const childrenClasses = {
            depreciated: !this.props.noLeftPaddingOnChildren,
            helperLabel: !this.props.noLeftPaddingOnChildren,
        };
        if (!this.props.alwaysShowChildren) {
            childrenClasses[CONST_1.UI.HIDDEN] = !this.state.checked;
        }
        const children = this.props.children ? react_1.default.createElement("div", { className: (0, classnames_1.default)(childrenClasses) }, this.props.children) : null;
        // Only use dangerouslySetInnerHTML if we explicitly pass safeDescription as a parameter.
        // Otherwise, just set the description inside a div
        // We use dangerouslySetInnerHTML, which could introduce XSS vulnerabilities if derived from user input,
        // to keep the description property simple without a bunch of nested HTML elements
        const description = this.state.preventEdit && this.state.preventEditDescription ? this.state.preventEditDescription : this.props.description;
        let descriptionElm = null;
        if (description && (this.state.checked || !this.props.onlyShowDescriptionWhenOn)) {
            if (this.props.safeDescription) {
                descriptionElm = (react_1.default.createElement("div", { className: "depreciated helperLabel", 
                    // eslint-disable-next-line react/no-danger
                    dangerouslySetInnerHTML: { __html: description } }));
            }
            else {
                descriptionElm = react_1.default.createElement("div", { className: "depreciated helperLabel" }, description);
            }
        }
        return (react_1.default.createElement("div", null,
            this.props.label && !this.props.labelOnRight && (react_1.default.createElement("label", { className: (0, classnames_1.default)(this.props.labelClasses), htmlFor: this.props.id }, this.props.label)),
            react_1.default.createElement(switch_1.default, { id: this.props.id, checked: this.state.checked, disabled: this.state.preventEdit, onChange: this.onChangeCallback, extraClasses: [this.props.extraClasses, { marginLeft10: !this.props.labelOnRight }], hideEnabledDisabledText: this.props.hideEnabledDisabledText, tooltipText: this.props.tooltipText }),
            this.props.label && this.props.labelOnRight && (react_1.default.createElement("label", { className: (0, classnames_1.default)(this.props.labelClasses, 'marginLeft5'), htmlFor: this.props.id }, this.props.label)),
            this.props.descriptionBeforeChildren ? (react_1.default.createElement("div", null,
                descriptionElm,
                children)) : (react_1.default.createElement("div", null,
                children,
                descriptionElm))));
    }
}
OnOffSwitch.propTypes = propTypes;
OnOffSwitch.defaultProps = defaultProps;
exports.default = OnOffSwitch;
