"use strict";
'worklet';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _reactNative = require("react-native");
var _expensifyCommon = require("expensify-common");
var _utils = require("expensify-common/dist/utils");
var _htmlEntities = require("html-entities");
var _rangeUtils = require("./rangeUtils.js");
function isWeb() {
  return _reactNative.Platform.OS === 'web';
}
function isJest() {
  return !!global.process.env.JEST_WORKER_ID;
}

// eslint-disable-next-line no-underscore-dangle
if (__DEV__ && !isWeb() && !isJest() && _htmlEntities.decode.__workletHash === undefined) {
  throw new Error("[react-native-live-markdown] `parseExpensiMark` requires `html-entities` package to be workletized. Please add `'worklet';` directive at the top of `node_modules/html-entities/lib/index.js` using patch-package. Make sure you've installed `html-entities` version 2.5.3 exactly as otherwise there is no `lib/` directory.");
}
const MAX_PARSABLE_LENGTH = 4000;
function parseMarkdownToHTML(markdown) {
  const parser = new _expensifyCommon.ExpensiMark();
  const html = parser.replace(markdown, {
    shouldKeepRawInput: true
  });
  return html;
}
function parseHTMLToTokens(html) {
  const tokens = [];
  let left = 0;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const open = html.indexOf('<', left);
    if (open === -1) {
      if (left < html.length) {
        tokens.push(['TEXT', html.substring(left)]);
      }
      break;
    }
    if (open !== left) {
      tokens.push(['TEXT', html.substring(left, open)]);
    }
    const close = html.indexOf('>', open);
    if (close === -1) {
      throw new Error('[react-native-live-markdown] Error in function parseHTMLToTokens: Invalid HTML: no matching ">"');
    }
    tokens.push(['HTML', html.substring(open, close + 1)]);
    left = close + 1;
  }
  return tokens;
}
function parseTokensToTree(tokens) {
  const stack = [{
    tag: '<>',
    children: []
  }];
  tokens.forEach(([type, payload]) => {
    if (type === 'TEXT') {
      const text = (0, _utils.unescapeText)(payload);
      const top = stack[stack.length - 1];
      top.children.push(text);
    } else if (type === 'HTML') {
      if (payload.startsWith('</')) {
        // closing tag
        const child = stack.pop();
        const top = stack[stack.length - 1];
        top.children.push(child);
      } else if (payload.endsWith('/>')) {
        // self-closing tag
        const top = stack[stack.length - 1];
        top.children.push({
          tag: payload,
          children: []
        });
      } else {
        // opening tag
        stack.push({
          tag: payload,
          children: []
        });
      }
    } else {
      throw new Error(`[react-native-live-markdown] Error in function parseTokensToTree: Unknown token type: ${type}. Expected 'TEXT' or 'HTML'. Please ensure tokens only contain these types.`);
    }
  });
  if (stack.length !== 1) {
    const unclosedTags = stack.length > 0 ? stack.slice(1).map(item => item.tag).join(', ') : '';
    throw new Error(`[react-native-live-markdown] Invalid HTML structure: the following tags are not properly closed: ${unclosedTags}. Ensure each opening tag has a corresponding closing tag.`);
  }
  return stack[0];
}
function parseTreeToTextAndRanges(tree) {
  let text = '';
  function processChildren(node) {
    if (typeof node === 'string') {
      text += node;
    } else {
      node.children.forEach(dfs);
    }
  }
  function appendSyntax(syntax) {
    addChildrenWithStyle(syntax, 'syntax');
  }
  function addChildrenWithStyle(node, type) {
    const start = text.length;
    processChildren(node);
    const end = text.length;
    ranges.push({
      type,
      start,
      length: end - start
    });
  }
  const ranges = [];
  function dfs(node) {
    if (typeof node === 'string') {
      text += node;
    } else {
      // eslint-disable-next-line no-lonely-if
      if (node.tag === '<>') {
        processChildren(node);
      } else if (node.tag === '<strong>') {
        appendSyntax('*');
        addChildrenWithStyle(node, 'bold');
        appendSyntax('*');
      } else if (node.tag === '<em>') {
        appendSyntax('_');
        addChildrenWithStyle(node, 'italic');
        appendSyntax('_');
      } else if (node.tag === '<del>') {
        appendSyntax('~');
        addChildrenWithStyle(node, 'strikethrough');
        appendSyntax('~');
      } else if (node.tag === '<emoji>') {
        addChildrenWithStyle(node, 'emoji');
      } else if (node.tag === '<code>') {
        appendSyntax('`');
        addChildrenWithStyle(node, 'code');
        appendSyntax('`');
      } else if (node.tag === '<mention-here>') {
        addChildrenWithStyle(node, 'mention-here');
      } else if (node.tag === '<mention-user>') {
        addChildrenWithStyle(node, 'mention-user');
      } else if (node.tag === '<mention-short>') {
        addChildrenWithStyle(node, 'mention-short');
      } else if (node.tag === '<mention-report>') {
        addChildrenWithStyle(node, 'mention-report');
      } else if (node.tag === '<blockquote>') {
        appendSyntax('>');
        addChildrenWithStyle(node, 'blockquote');
        // compensate for "> " at the beginning
        if (ranges.length > 0) {
          const curr = ranges[ranges.length - 1];
          curr.start -= 1;
          curr.length += 1;
        }
      } else if (node.tag === '<h1>') {
        appendSyntax('# ');
        addChildrenWithStyle(node, 'h1');
      } else if (node.tag === '<br />') {
        text += '\n';
      } else if (node.tag.startsWith('<pre')) {
        const [_, lb, content] = node.children.join('').match(/^(\r?\n)([\s\S]*)$/) ?? [];
        // Adding opening ("```${lb}") and closing ("```") codeblock syntax length, equal to 7, to the content length
        ranges.push({
          type: 'codeblock',
          start: text.length,
          length: (content?.length ?? 0) + 7
        });
        appendSyntax(`\`\`\`${lb}`);
        addChildrenWithStyle(`${content}`, 'pre');
        appendSyntax('```');
      } else if (node.tag.startsWith('<a href="')) {
        const rawHref = node.tag.match(/href="([^"]*)"/)[1]; // always present
        const href = (0, _utils.unescapeText)(rawHref);
        const isLabeledLink = node.tag.match(/data-link-variant="([^"]*)"/)[1] === 'labeled';
        const dataRawHref = node.tag.match(/data-raw-href="([^"]*)"/);
        const matchString = dataRawHref ? (0, _utils.unescapeText)(dataRawHref[1]) : href;
        if (!isLabeledLink && node.children.length === 1 && typeof node.children[0] === 'string' && (node.children[0] === matchString || `mailto:${node.children[0]}` === href)) {
          addChildrenWithStyle(node.children[0], 'link');
        } else {
          appendSyntax('[');
          processChildren(node);
          appendSyntax('](');
          addChildrenWithStyle(matchString, 'link');
          appendSyntax(')');
        }
      } else if (node.tag.startsWith('<img src="')) {
        const src = node.tag.match(/src="([^"]*)"/)[1]; // always present
        const alt = node.tag.match(/alt="([^"]*)"/);
        const hasAlt = node.tag.match(/data-link-variant="([^"]*)"/)[1] === 'labeled';
        const rawLink = node.tag.match(/data-raw-href="([^"]*)"/);
        const linkString = rawLink ? (0, _utils.unescapeText)(rawLink[1]) : src;
        const start = text.length;
        const length = 3 + (hasAlt ? 2 + (0, _utils.unescapeText)(alt?.[1] || '').length : 0) + linkString.length;
        ranges.push({
          type: 'inline-image',
          start,
          length
        });
        appendSyntax('!');
        if (hasAlt) {
          appendSyntax('[');
          processChildren((0, _utils.unescapeText)(alt?.[1] || ''));
          appendSyntax(']');
        }
        appendSyntax('(');
        addChildrenWithStyle(linkString, 'link');
        appendSyntax(')');
      } else if (node.tag.startsWith('<video data-expensify-source="')) {
        const src = node.tag.match(/data-expensify-source="([^"]*)"/)[1]; // always present
        const rawLink = node.tag.match(/data-raw-href="([^"]*)"/);
        const hasAlt = node.tag.match(/data-link-variant="([^"]*)"/)[1] === 'labeled';
        const linkString = rawLink ? (0, _utils.unescapeText)(rawLink[1]) : src;
        appendSyntax('!');
        if (hasAlt) {
          appendSyntax('[');
          node.children.forEach(child => processChildren(child));
          appendSyntax(']');
        }
        appendSyntax('(');
        addChildrenWithStyle(linkString, 'link');
        appendSyntax(')');
      } else {
        throw new Error(`[react-native-live-markdown] Error in function parseTreeToTextAndRanges: Unknown tag '${node.tag}'. This tag is not supported in this function's logic.`);
      }
    }
  }
  dfs(tree);
  return [text, ranges];
}
const isNative = _reactNative.Platform.OS === 'android' || _reactNative.Platform.OS === 'ios';
function parseExpensiMark(markdown) {
  if (markdown.length > MAX_PARSABLE_LENGTH) {
    return [];
  }
  const html = parseMarkdownToHTML(markdown);
  const tokens = parseHTMLToTokens(html);
  const tree = parseTokensToTree(tokens);
  const [text, ranges] = parseTreeToTextAndRanges(tree);
  if (text !== markdown) {
    console.error(`[react-native-live-markdown] Parsing error: the processed text does not match the original Markdown input. This may be caused by incorrect parsing functions or invalid input Markdown.\nProcessed input: '${JSON.stringify(text)}'\nOriginal input: '${JSON.stringify(markdown)}'`);
    return [];
  }
  let markdownRanges = (0, _rangeUtils.sortRanges)(ranges);
  if (isNative) {
    // Blocks applying italic and strikethrough styles to emojis on Android and iOS
    // TODO: Remove this condition when splitting emojis inside the inline code block will be fixed on the web
    markdownRanges = (0, _rangeUtils.splitRangesOnEmojis)(markdownRanges, 'italic');
    markdownRanges = (0, _rangeUtils.splitRangesOnEmojis)(markdownRanges, 'strikethrough');
  }
  const groupedRanges = (0, _rangeUtils.groupRanges)(markdownRanges);
  return groupedRanges;
}
var _default = exports.default = parseExpensiMark;
//# sourceMappingURL=parseExpensiMark.js.map