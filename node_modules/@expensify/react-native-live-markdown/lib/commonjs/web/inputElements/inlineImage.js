"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addInlineImagePreview = addInlineImagePreview;
exports.forceRefreshAllImages = forceRefreshAllImages;
var _styleUtils = require("../../styleUtils.js");
var _loadingIndicator = require("./loadingIndicator.js");
const INLINE_IMAGE_PREVIEW_DEBOUNCE_TIME_MS = 300;
const INLINE_IMAGE_MIN_HEIGHT = 40;
const inlineImageDefaultStyles = {
  position: 'absolute',
  bottom: 0,
  left: 0
};
const timeoutMap = new Map();
function getImagePreviewElement(targetElement) {
  return Array.from(targetElement?.childNodes || []).find(el => el?.contentEditable === 'false');
}
function getContainerPaddingBottom(imageHeight, imagePaddingTop) {
  return `${Math.max(INLINE_IMAGE_MIN_HEIGHT, imageHeight) + imagePaddingTop}px`;
}
function scaleImageDimensions(imgElement) {
  const {
    height,
    width
  } = imgElement;
  const {
    maxHeight,
    maxWidth,
    minHeight,
    minWidth
  } = imgElement.style || {};
  const maxHeightValue = (0, _styleUtils.parseStringWithUnitToNumber)(maxHeight);
  const maxWidthValue = (0, _styleUtils.parseStringWithUnitToNumber)(maxWidth);
  const minHeightValue = (0, _styleUtils.parseStringWithUnitToNumber)(minHeight);
  const minWidthValue = (0, _styleUtils.parseStringWithUnitToNumber)(minWidth);

  // Calculate the initial aspect ratio
  const aspectRatio = width / height;

  // Define scaled dimensions initializing with original dimensions.
  let scaledWidth = width;
  let scaledHeight = height;

  // Check and apply maxWidth and maxHeight constraints
  if (maxWidthValue && scaledWidth > maxWidthValue) {
    scaledWidth = maxWidthValue;
    scaledHeight = scaledWidth / aspectRatio;
  }
  if (maxHeight && scaledHeight > maxHeightValue) {
    scaledHeight = maxHeightValue;
    scaledWidth = scaledHeight * aspectRatio;
  }

  // Double-check dimensions after first scaling
  if (scaledWidth > maxWidthValue) {
    scaledWidth = maxWidthValue;
    scaledHeight = scaledWidth / aspectRatio;
  }

  // Check and apply minWidth and minHeight constraints
  if (minWidthValue && scaledWidth < minWidthValue) {
    scaledWidth = minWidthValue;
    scaledHeight = scaledWidth / aspectRatio;
  }
  if (minHeightValue && scaledHeight < minHeightValue) {
    scaledHeight = minHeightValue;
    scaledWidth = scaledHeight * aspectRatio;
  }

  // Double-check dimensions after second scaling
  if (scaledHeight < minHeightValue) {
    scaledHeight = minHeightValue;
    scaledWidth = scaledHeight * aspectRatio;
  }
  return {
    height: scaledHeight,
    width: scaledWidth
  };
}
function handleOnLoad(currentInput, target, imageHref, markdownStyle, imageContainer, err) {
  let targetElement = target;

  // Update the target element if the input structure was changed while the image was loading and its content hasn't changed
  if (!targetElement.isConnected) {
    const currentElement = currentInput.querySelector(`[data-type="block"][data-id="${target.getAttribute('data-id')}"]`);
    const currentElementURL = getImagePreviewElement(currentElement)?.getAttribute('data-url');
    const targetElementURL = getImagePreviewElement(targetElement)?.getAttribute('data-url');
    if (currentElementURL && targetElementURL && currentElementURL === targetElementURL) {
      targetElement = currentElement;
    } else {
      return; // Prevent adding expired image previews to the input structure
    }
  }

  // Verify if the current spinner is for the loaded image. If not, it means that the response came after the user changed the image url
  const currentSpinner = currentInput.querySelector(`[data-type="spinner"][data-url="${imageHref}"]`);

  // Remove the spinner
  if (currentSpinner) {
    currentSpinner.remove();
  }
  const img = imageContainer.firstChild;
  const {
    minHeight,
    minWidth,
    maxHeight,
    maxWidth,
    borderRadius
  } = markdownStyle.inlineImage || {};
  const imgStyle = {
    minHeight,
    minWidth,
    maxHeight,
    maxWidth,
    borderRadius
  };

  // Set the image styles
  Object.assign(imageContainer.style, {
    ...inlineImageDefaultStyles,
    ...(err && {
      ...imgStyle,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    })
  });
  Object.assign(img.style, !err && imgStyle);
  targetElement.appendChild(imageContainer);
  const currentInputElement = currentInput;
  if (currentInput.imageElements) {
    currentInputElement.imageElements.push(img);
  } else {
    currentInputElement.imageElements = [img];
  }
  const scaledImageHeight = scaleImageDimensions(img).height;
  Object.assign(imageContainer.style, {
    height: `${scaledImageHeight}px`
  });
  // Set paddingBottom to the height of the image so it's displayed under the block
  const imageMarginTop = (0, _styleUtils.parseStringWithUnitToNumber)(`${markdownStyle.inlineImage?.marginTop}`);
  Object.assign(targetElement.style, {
    paddingBottom: getContainerPaddingBottom(scaledImageHeight, imageMarginTop)
  });
}
function createImageElement(currentInput, targetNode, url, markdownStyle) {
  if (timeoutMap.has(targetNode.orderIndex)) {
    const mapItem = timeoutMap.get(targetNode.orderIndex);
    // Check if the image URL has been changed, if not, early return so the image can be loaded asynchronously
    const currentElement = currentInput.querySelector(`[data-type="block"][data-id="${targetNode.orderIndex}"]`);
    if (mapItem?.url === url && currentElement && getImagePreviewElement(currentElement)) {
      return;
    }
    clearTimeout(mapItem?.timeout);
    timeoutMap.delete(targetNode.orderIndex);
  }
  const timeout = setTimeout(() => {
    const imageContainer = document.createElement('span');
    imageContainer.contentEditable = 'false';
    imageContainer.setAttribute('data-type', 'inline-container');
    const img = new Image();
    imageContainer.appendChild(img);
    img.contentEditable = 'false';
    img.onload = () => handleOnLoad(currentInput, targetNode.element, url, markdownStyle, imageContainer);
    img.onerror = err => handleOnLoad(currentInput, targetNode.element, url, markdownStyle, imageContainer, err);
    img.src = url;
    timeoutMap.delete(targetNode.orderIndex);
  }, INLINE_IMAGE_PREVIEW_DEBOUNCE_TIME_MS);
  timeoutMap.set(`${currentInput.uniqueId}-${targetNode.orderIndex}`, {
    timeout,
    url
  });
}

/** Adds already loaded image element from current input content to the tree node */
function updateImageTreeNode(targetNode, newElement, imageMarginTop = 0) {
  const paddingBottom = getContainerPaddingBottom((0, _styleUtils.parseStringWithUnitToNumber)(newElement.style.height), imageMarginTop);
  targetNode.element.appendChild(newElement.cloneNode(true));
  let currentParent = targetNode.element;
  while (currentParent.parentElement && !['line', 'block'].includes(currentParent.getAttribute('data-type') || '')) {
    currentParent = currentParent.parentElement;
  }
  Object.assign(currentParent.style, {
    paddingBottom
  });
  return targetNode;
}

/** The main function that adds inline image preview to the node */
function addInlineImagePreview(currentInput, targetNode, text, ranges, markdownStyle, inlineImagesProps) {
  const {
    addAuthTokenToImageURLCallback,
    imagePreviewAuthRequiredURLs
  } = inlineImagesProps;
  const linkRange = ranges.find(r => r.type === 'link');
  let imageHref = '';
  if (linkRange) {
    imageHref = text.substring(linkRange.start, linkRange.start + linkRange.length);
    if (addAuthTokenToImageURLCallback && imagePreviewAuthRequiredURLs && imagePreviewAuthRequiredURLs.find(url => imageHref.startsWith(url))) {
      imageHref = addAuthTokenToImageURLCallback(imageHref);
    }
  }
  const imageMarginTop = (0, _styleUtils.parseStringWithUnitToNumber)(`${markdownStyle.inlineImage?.marginTop}`);
  const imageMarginBottom = (0, _styleUtils.parseStringWithUnitToNumber)(`${markdownStyle.inlineImage?.marginBottom}`);

  // If the inline image markdown with the same href exists in the current input, use it instead of creating new one.
  // Prevents from image flickering and layout jumps
  const alreadyLoadedPreview = currentInput.imageElements?.find(el => el?.src === imageHref);
  const loadedImageContainer = alreadyLoadedPreview?.parentElement;
  if (loadedImageContainer && loadedImageContainer.getAttribute('data-type') === 'inline-container') {
    return updateImageTreeNode(targetNode, loadedImageContainer, imageMarginTop);
  }

  // Add a loading spinner
  const spinner = (0, _loadingIndicator.createLoadingIndicator)(imageHref, markdownStyle);
  if (spinner) {
    targetNode.element.appendChild(spinner);
  }
  Object.assign(targetNode.element.style, {
    display: 'block',
    marginBottom: `${imageMarginBottom}px`,
    paddingBottom: markdownStyle.loadingIndicatorContainer?.height || markdownStyle.loadingIndicator?.height || !!markdownStyle.loadingIndicator && '30px' || undefined
  });
  createImageElement(currentInput, targetNode, imageHref, markdownStyle);
  return targetNode;
}
function forceRefreshAllImages(currentInput, markdownStyle) {
  currentInput?.querySelectorAll('img').forEach(img => {
    // force image reload only if broken image icon is displayed
    if (img.naturalWidth > 0) {
      return;
    }
    const url = img.src;
    const imgElement = img;
    imgElement.src = '';
    imgElement.onload = () => handleOnLoad(currentInput, img.parentElement?.parentElement, url, markdownStyle, img.parentElement);
    imgElement.src = `${url}#`;
  });
}

// eslint-disable-next-line import/prefer-default-export
//# sourceMappingURL=inlineImage.js.map