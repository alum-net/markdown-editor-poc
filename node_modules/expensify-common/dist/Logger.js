"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MAX_LOG_LINES_BEFORE_FLUSH = 50;
class Logger {
    constructor({ serverLoggingCallback, isDebug, clientLoggingCallback, maxLogLinesBeforeFlush }) {
        // An array of log lines that limits itself to a certain number of entries (deleting the oldest)
        this.logLines = [];
        this.serverLoggingCallback = serverLoggingCallback;
        this.clientLoggingCallback = clientLoggingCallback;
        this.isDebug = isDebug;
        this.maxLogLinesBeforeFlush = maxLogLinesBeforeFlush || MAX_LOG_LINES_BEFORE_FLUSH;
        // Public Methods
        this.info = this.info.bind(this);
        this.alert = this.alert.bind(this);
        this.warn = this.warn.bind(this);
        this.hmmm = this.hmmm.bind(this);
        this.client = this.client.bind(this);
    }
    /**
     * Ask the server to write the log message
     */
    logToServer() {
        var _a, _b;
        // We do not want to call the server with an empty list or if all the lines has onlyFlushWithOthers=true
        if (!this.logLines.length || ((_a = this.logLines) === null || _a === void 0 ? void 0 : _a.every((l) => l.onlyFlushWithOthers))) {
            return;
        }
        // We don't care about log setting web cookies so let's define it as false
        const linesToLog = (_b = this.logLines) === null || _b === void 0 ? void 0 : _b.map((l) => {
            // eslint-disable-next-line no-param-reassign
            delete l.onlyFlushWithOthers;
            return l;
        });
        this.logLines = [];
        const promise = this.serverLoggingCallback(this, { api_setCookie: false, logPacket: JSON.stringify(linesToLog) });
        if (!promise) {
            return;
        }
        // eslint-disable-next-line rulesdir/prefer-early-return
        promise.then((response) => {
            if (!response.requestID) {
                return;
            }
            this.info('Previous log requestID', false, { requestID: response.requestID }, true);
        });
    }
    /**
     * Add a message to the list
     * @param parameters The parameters associated with the message
     * @param forceFlushToServer Should we force flushing all logs to server?
     * @param onlyFlushWithOthers A request will never be sent to the server if all loglines have this set to true
     */
    add(message, parameters, forceFlushToServer, onlyFlushWithOthers = false, extraData = '') {
        const length = this.logLines.push({
            message,
            parameters,
            onlyFlushWithOthers,
            timestamp: new Date(),
        });
        if (this.isDebug) {
            this.client(`${message} - ${JSON.stringify(parameters)}`, extraData);
        }
        // If we're over the limit, flush the logs
        if (length > this.maxLogLinesBeforeFlush || forceFlushToServer) {
            this.logToServer();
        }
    }
    /**
     * Caches an informational message locally, to be sent to the server if
     * needed later.
     *
     * @param message The message to log.
     * @param sendNow if true, the message will be sent right away.
     * @param parameters The parameters to send along with the message
     * @param onlyFlushWithOthers A request will never be sent to the server if all loglines have this set to true
     */
    info(message, sendNow = false, parameters = '', onlyFlushWithOthers = false, extraData = '') {
        const msg = `[info] ${message}`;
        this.add(msg, parameters, sendNow, onlyFlushWithOthers, extraData);
    }
    /**
     * Logs an alert.
     *
     * @param message The message to alert.
     * @param parameters The parameters to send along with the message
     * @param includeStackTrace Must be disabled for testing
     */
    alert(message, parameters = {}, includeStackTrace = true) {
        const msg = `[alrt] ${message}`;
        const params = parameters;
        if (includeStackTrace && typeof params === 'object' && !Array.isArray(params)) {
            params.stack = JSON.stringify(new Error().stack);
        }
        this.add(msg, params, true);
    }
    /**
     * Logs a warn.
     *
     * @param {String} message The message to warn.
     * @param {Object|String} parameters The parameters to send along with the message
     */
    warn(message, parameters = '') {
        const msg = `[warn] ${message}`;
        this.add(msg, parameters, true);
    }
    /**
     * Logs a hmmm.
     *
     * @param message The message to hmmm.
     * @param parameters The parameters to send along with the message
     */
    hmmm(message, parameters = '') {
        const msg = `[hmmm] ${message}`;
        this.add(msg, parameters, false);
    }
    /**
     * Logs a message in the browser console.
     *
     * @param message The message to log.
     */
    client(message, extraData = '') {
        if (!this.clientLoggingCallback) {
            return;
        }
        this.clientLoggingCallback(message, extraData);
    }
}
exports.default = Logger;
